import "string"

#pragma link("mega65hyper.ld")

//Definitions
const char* RASTER = 0xd012;
const char* VIC_MEMORY = 0xd018;
const char* SCREEN = 0x0400;
const char* BGCOL = 0xd021;
const char* COLS = 0xd800;
const char BLACK = 0;
const char WHITE = 1;

//The text to display
char[] MESSAGE = "checkpoint 2.2 by smit1829";

void main(){
  //Init screen memory and font
  *VIC_MEMORY = 0x14;
  //Fill the screen with spaces
  memset(SCREEN, ' ', 40*25);
  //Set the colour of every char to white
  memset(COLS, WHITE, 40*25);
  //Print the message
  char* sc = SCREEN+40; //Start one line down
  char* msg = MESSAGE;
  //Routine to copy the string
  while(*msg){
    *sc++ = *msg++;
  }
  //Loop forever, showing 2 white lines
  while(true){
    if(*RASTER==54 || *RASTER==66){
      *BGCOL = WHITE;
    } else {
      *BGCOL = BLACK;
    }
  }
}

//Trigger the system to exit hypervisor mode
void exit_hypervisor(){
  *(unsigned char *)$D67F = $01;
}

//SYSCALL Handlers to display a character
void syscall1(){
  *(SCREEN+79) = ')';
}

void syscall2(){
  *(SCREEN+78) = '(';
}

//The rest of the SYSCALL handler functions
void syscall3(){

}

void syscall4(){
  
}

void syscall5(){
  
}

void syscall6(){
  
}

void syscall7(){
  
}

void syscall8(){
  
}

void syscall9(){
  
}

void syscall10(){

}

void securentr(){

}

void securexit(){

}

void syscall13(){

}

void syscall14(){

}

void syscall15(){
  
}

void syscall16(){

}

void syscall17(){

}

void syscall18(){

}

void syscall19(){

}

void syscall20(){

}

void syscall21(){

}

void syscall22(){

}

void syscall23(){

}

void syscall24(){

}

void syscall25(){

}

void syscall26(){

}

void syscall27(){

}

void syscall28(){

}

void syscall29(){

}

void syscall30(){

}

void syscall31(){

}

void syscall32(){

}

void syscall33(){

}

void syscall34(){

}

void syscall35(){
  
}

void syscall36(){

}

void syscall37(){

}

void syscall38(){

}

void syscall39(){

}

void syscall40(){

}

void syscall41(){

}

void syscall42(){

}

void syscall43(){

}

void syscall44(){

}

void syscall45(){

}

void syscall46(){

}

void syscall47(){

}

void syscall48(){

}

void syscall49(){

}

void syscall50(){

}

void syscall51(){

}

void syscall52(){

}

void syscall53(){

}

void syscall54(){

}

void syscall55(){

}

void syscall56(){

}

void syscall57(){

}

void syscall58(){

}

void syscall59(){

}

void syscall60(){

}

void syscall61(){

}

void syscall62(){

}

void syscall63(){

}

void syscall64(){
  
}

//The Trap Functions
//Power-on/reset entry point
void reset(){
  
}
//Page fault entry point
void pagfault(){

}
//Restore-key long press trap entry point
void restorkey(){

}
//Alt+Tab trap entry point
void alttabkey(){

}
//F011 virtualised disk read trap entry point
void VF011RD(){

}
//F011 virtualised disk write trap entry point
void VF011WR(){

}
//Trap function for all undefined traps
void reserved_trap(){

}
//KIL instruction in 6502-mode trap entry point
void CPUKIL(){

}

//Select the SYSCALL segment
#pragma data_seg(Syscall)

//Struct for the syscall
struct SysCall{
  char xjmp;
  void()* syscall;
  char xnop;
};

//Define consts
const char JMP = 0x4c;
const char NOP = 0xea;

//Fill in struct
export struct SysCall[] SYSCALLS= {
  {JMP, &syscall1, NOP},
  {JMP, &syscall2, NOP},
  {JMP, &syscall3, NOP},
  {JMP, &syscall4, NOP},
  {JMP, &syscall5, NOP},
  {JMP, &syscall6, NOP},
  {JMP, &syscall7, NOP},
  {JMP, &syscall8, NOP},
  {JMP, &syscall9, NOP},
  {JMP, &syscall10, NOP},
  {JMP, &securentr, NOP},
  {JMP, &securexit, NOP},
  {JMP, &syscall13, NOP},
  {JMP, &syscall14, NOP},
  {JMP, &syscall15, NOP},
  {JMP, &syscall16, NOP},
  {JMP, &syscall17, NOP},
  {JMP, &syscall18, NOP},
  {JMP, &syscall19, NOP},
  {JMP, &syscall20, NOP},
  {JMP, &syscall21, NOP},
  {JMP, &syscall22, NOP},
  {JMP, &syscall23, NOP},
  {JMP, &syscall24, NOP},
  {JMP, &syscall25, NOP},
  {JMP, &syscall26, NOP},
  {JMP, &syscall27, NOP},
  {JMP, &syscall28, NOP},
  {JMP, &syscall29, NOP},
  {JMP, &syscall30, NOP},
  {JMP, &syscall31, NOP},
  {JMP, &syscall32, NOP},
  {JMP, &syscall33, NOP},
  {JMP, &syscall34, NOP},
  {JMP, &syscall35, NOP},
  {JMP, &syscall36, NOP},
  {JMP, &syscall37, NOP},
  {JMP, &syscall38, NOP},
  {JMP, &syscall39, NOP},
  {JMP, &syscall40, NOP},
  {JMP, &syscall41, NOP},
  {JMP, &syscall42, NOP},
  {JMP, &syscall43, NOP},
  {JMP, &syscall44, NOP},
  {JMP, &syscall45, NOP},
  {JMP, &syscall46, NOP},
  {JMP, &syscall47, NOP},
  {JMP, &syscall48, NOP},
  {JMP, &syscall49, NOP},
  {JMP, &syscall50, NOP},
  {JMP, &syscall51, NOP},
  {JMP, &syscall52, NOP},
  {JMP, &syscall53, NOP},
  {JMP, &syscall54, NOP},
  {JMP, &syscall55, NOP},
  {JMP, &syscall56, NOP},
  {JMP, &syscall57, NOP},
  {JMP, &syscall58, NOP},
  {JMP, &syscall59, NOP},
  {JMP, &syscall60, NOP},
  {JMP, &syscall61, NOP},
  {JMP, &syscall62, NOP},
  {JMP, &syscall63, NOP},
  {JMP, &syscall64, NOP}

};

//Create traps

struct SysCall[] TRAPS = {
  {JMP, &reset, NOP},
  {JMP, &pagfault, NOP},
  {JMP, &restorkey, NOP},
  {JMP, &alttabkey, NOP},
  {JMP, &VF011RD, NOP},
  {JMP, &VF011WR, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &reserved_trap, NOP},
  {JMP, &CPUKIL, NOP}
};

